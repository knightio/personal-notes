# 共享模型之管程

## 共享带来的问题

### 临界区

+ 一个程序运行多个线程本身是没有问题的
+ 问题出在多个线程访问**共享资源**
  + 多个线程读**共享资源**其实也没有问题
  + 在多个线程对**共享资源**读写操作时发生指令交错，就会出现问题
+ 一段代码块内如果存在对**共享资源**的多线程读写操作，称这段代码块为**临界区**

例如，下面代码中的临界区

``` java
static int counter = 0;
static void increment() 
// 临界区
{ 
    counter++; 
}
static void decrement() 
// 临界区
{ 
    counter--; 
}
```

### 竞态条件

多个线程在临界区内执行，由于代码的**执行序列**不同而导致结果无法预测，称之为发生了**竞态条件**  

## synchronized 解决方案

### 应用之互斥

为了避免临界区的竞态条件发生，有多种手段可以达到目的。

+ 阻塞式的解决方案：synchronized，Lock
+ 非阻塞式的解决方案：原子变量

> **注意**  
> 虽然 java 中互斥和同步都可以采用 synchronized 关键字来完成，但它们还是有区别的：
>
> + 互斥是保证临界区的竞态条件发生，同一时刻只能有一个线程执行临界区代码
> + 同步是由于线程执行的先后、顺序不同、需要一个线程等待其它线程运行到某个点

### synchronized

语法

``` java
synchronized(对象) // 线程1， 线程2(blocked)
{
    临界区
}
```

### 思考

synchronized 实际是用**对象锁**保证了临界区内代码的**原子性**，临界区内的代码对外是不可分割的，不会被线程切换所打断。

