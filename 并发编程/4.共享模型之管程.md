# 共享模型之管程

## 共享带来的问题

### **临界区**

+ 一个程序运行多个线程本身是没有问题的
+ 问题出在多个线程访问**共享资源**
  + 多个线程读**共享资源**其实也没有问题
  + 在多个线程对**共享资源**读写操作时发生指令交错，就会出现问题
+ 一段代码块内如果存在对**共享资源**的多线程读写操作，称这段代码块为**临界区**

例如，下面代码中的临界区

``` java
static int counter = 0;
static void increment() 
// 临界区
{ 
    counter++; 
}
static void decrement() 
// 临界区
{ 
    counter--; 
}
```

### **竞态条件**

多个线程在临界区内执行，由于代码的**执行序列**不同而导致结果无法预测，称之为发生了**竞态条件**  

## synchronized 解决方案

### **应用之互斥**

为了避免临界区的竞态条件发生，有多种手段可以达到目的。

+ 阻塞式的解决方案：synchronized，Lock
+ 非阻塞式的解决方案：原子变量

> **注意**  
> 虽然 java 中互斥和同步都可以采用 synchronized 关键字来完成，但它们还是有区别的：
>
> + 互斥是保证临界区的竞态条件发生，同一时刻只能有一个线程执行临界区代码
> + 同步是由于线程执行的先后、顺序不同、需要一个线程等待其它线程运行到某个点

### **synchronized**

语法

``` java
synchronized(对象) // 线程1， 线程2(blocked)
{
    临界区
}
```

### **思考**

synchronized 实际是用**对象锁**保证了临界区内代码的**原子性**，临界区内的代码对外是不可分割的，不会被线程切换所打断。

## 方法上的 synchronized

``` java
class Test{
    public synchronized void test() {

    }
}
//等价于
class Test{
    public void test() {
        synchronized(this) {
 
        }
    }
}
```

``` java
class Test{
    public synchronized static void test() {
    }
}
//等价于
class Test{
    public static void test() {
        synchronized(Test.class) {
 
        }
    }
}
```

### **不加 synchronized 的方法**

不加 synchronzied 的方法就好比不遵守规则的人，不去老实排队（好比翻窗户进去的）

### **所谓的“线程八锁”**

情况1：12 或 21

``` java
@Slf4j(topic = "c.Number")
class Number{
    public synchronized void a() {
        log.debug("1");
    }
    public synchronized void b() {
        .debug("2");
    }
}
public static void main(String[] args) {
    Number n1 = new Number();
    new Thread(()->{ n1.a(); }).start();
    new Thread(()->{ n1.b(); }).start();
}
```

情况2：1s后 1 2 或 2 1s后 1

``` java
@Slf4j(topic = "c.Number")
class Number{
    public synchronized void a() {
        sleep(1);
        log.debug("1");
    }
    public synchronized void b() {
        log.debug("2");
    }
}
public static void main(String[] args) {
    Number n1 = new Number();
    new Thread(()->{ n1.a(); }).start();
    new Thread(()->{ n1.b(); }).start();
}
```

情况3：3 1s 12 或 23 1s 1 或 32 1s 1

``` java
@Slf4j(topic = "c.Number")
class Number{
    public synchronized void a() {
        sleep(1);
        log.debug("1");
    }
    public synchronized void b() {
        log.debug("2");
    }
    public void c() {
        log.debug("3");
    }
}
public static void main(String[] args) {
    Number n1 = new Number();
    new Thread(()->{ n1.a(); }).start();
    new Thread(()->{ n1.b(); }).start();
    new Thread(()->{ n1.c(); }).start();
}
```

情况4：2 1s 1

```java
@Slf4j(topic = "c.Number")
class Number{
    public synchronized void a() {
        sleep(1);
        log.debug("1");
    }
    public synchronized void b() {
        log.debug("2");
    }
}
public static void main(String[] args) {
    Number n1 = new Number();
    Number n2 = new Number();
    new Thread(()->{ n1.a(); }).start();
    new Thread(()->{ n2.b(); }).start();
}
```

情况5：2 1s 1

``` java
@Slf4j(topic = "c.Number")
class Number{
    public static synchronized void a() {
        sleep(1);
        log.debug("1");
    }
    public synchronized void b() {
        log.debug("2");
    }
}
public static void main(String[] args) {
    Number n1 = new Number();
    new Thread(()->{ n1.a(); }).start();
    new Thread(()->{ n1.b(); }).start();
}
```

情况6：1s 后12， 或 2 1s后 1

```java
@Slf4j(topic = "c.Number")
class Number{
    public static synchronized void a() {
        sleep(1);
        log.debug("1");
    }
    public static synchronized void b() {
        log.debug("2");
    }
}
public static void main(String[] args) {
    Number n1 = new Number();
    new Thread(()->{ n1.a(); }).start();
    new Thread(()->{ n1.b(); }).start();
}
```

情况7：2 1s 后 1

```java
@Slf4j(topic = "c.Number")
class Number{
    public static synchronized void a() {
        sleep(1);
        log.debug("1");
    }
    public synchronized void b() {
        log.debug("2");
    }
}
public static void main(String[] args) {
    Number n1 = new Number();
    Number n2 = new Number();
    new Thread(()->{ n1.a(); }).start();
    new Thread(()->{ n2.b(); }).start();
}
```

情况8：1s 后12， 或 2 1s后 

```java
@Slf4j(topic = "c.Number")
class Number{
    public static synchronized void a() {
        sleep(1);
        log.debug("1");
    }
    public static synchronized void b() {
        log.debug("2");
    }
}
public static void main(String[] args) {
    Number n1 = new Number();
    Number n2 = new Number();
    new Thread(()->{ n1.a(); }).start();
    new Thread(()->{ n2.b(); }).start();
}
```

## 变量的线程安全分析

### **成员变量和静态变量是否线程安全？**

+ 如果它们没有共享，则线程安全
+ 如果它们被共享了，根据它们的状态是否能够改变，又分两种情况
  + 如果只有读操作，则线程安全
  + 如果有读写操作，则这段代码是临界区，需要考虑线程安全
  
### **局部变量是否线程安全？**

+ 局部变量是线程安全的
+ 但局部变量**引用**的对象则未必
  + 如果该对象没有逃离方法的作用访问，它是线程安全的
  + 如果该对象逃离方法的作用范围，需要考虑线程安全

### **局部变量线程安全分析**

```java
public static void test1() {
    int i = 10;
    i++; 
}
````

每个线程调用 test1() 方法时局部变量 i，会在每个线程的栈帧内存中被创建多份，因此不存在共享。

局部变量的引用稍有不同

先看一个成员变量的例子

```java
class ThreadUnsafe {
    ArrayList<String> list = new ArrayList<>();
        public void method1(int loopNumber) {
            for (int i = 0; i < loopNumber; i++) {
                // { 临界区, 会产生竞态条件
                method2();
                method3();
                // } 临界区
            }
    }
    private void method2() {
        list.add("1");
    }
    private void method3() {
        list.remove(0);
    }
}
```

执行

```java
static final int THREAD_NUMBER = 2;
static final int LOOP_NUMBER = 200;
public static void main(String[] args) {
    ThreadUnsafe test = new ThreadUnsafe();
    for (int i = 0; i < THREAD_NUMBER; i++) {
        new Thread(() -> {
            test.method1(LOOP_NUMBER);
        }, "Thread" + i).start();
    }
}
```

其中一种情况是，如果线程2 还未 add，线程1 remove 就会报错：

```java
Exception in thread "Thread1" java.lang.IndexOutOfBoundsException: Index: 0, Size: 0 
        at java.util.ArrayList.rangeCheck(ArrayList.java:657) 
        at java.util.ArrayList.remove(ArrayList.java:496) 
        at cn.itcast.n6.ThreadUnsafe.method3(TestThreadSafe.java:35) 
        at cn.itcast.n6.ThreadUnsafe.method1(TestThreadSafe.java:26) 
        at cn.itcast.n6.TestThreadSafe.lambda$main$0(TestThreadSafe.java:14) 
        at java.lang.Thread.run(Thread.java:748)
```

分析：

+ 无论哪个线程中的 method2 引用的都是同一个对象中的 list 成员变量
+ method3 与 method2 分析相同
  
将 list 修改为局部变量

```java
class ThreadSafe {
    public final void method1(int loopNumber) {
        ArrayList<String> list = new ArrayList<>();
        for (int i = 0; i < loopNumber; i++) {
        method2(list);
        method3(list);
        }
    }
    private void method2(ArrayList<String> list) {
        list.add("1");
    }
    private void method3(ArrayList<String> list) {
        list.remove(0);
    }
}
```

那么就不会有上述问题了

分析：

+ list 是局部变量，每个线程调用时会创建其不同实例，没有共享
+ 而 method2 的参数是从 method1 中传递过来的，与 method1 中引用同一个对象
+ method3 的参数分析与 method2 相同

方法访问修饰符带来的思考，如果把 method2 和 method3 的方法修改为 public 会不会代理线程安全问题？

+ 情况1：有其它线程调用 method2 和 method3
+ 情况2：在 情况1 的基础上，为 ThreadSafe 类添加子类，子类覆盖 method2 或 method3 方法，即
  
    ```java
    class ThreadSafe {
        public final void method1(int loopNumber) {
            ArrayList<String> list = new ArrayList<>();
            for (int i = 0; i < loopNumber; i++) {
            method2(list);
            method3(list);
            }
        }
        private void method2(ArrayList<String> list) {
            list.add("1");
        }
        private void method3(ArrayList<String> list) {
            list.remove(0);
        }
    }
    class ThreadSafeSubClass extends ThreadSafe{
        @Override
        public void method3(ArrayList<String> list) {
            new Thread(() -> {
                list.remove(0);
            }).start();
        }
    }

    ```

    >从这个例子可以看出 private 或 final 提供【安全】的意义所在，请体会开闭原则中的【闭】
  